# Умные указатели

## Box

Тип `Box` позволяет управлять данными в куче. В отличие от значений с фиксированными размерами и временем жизни, которые хранятся в стеке, `Box` позволяет выделять память для известного типа в куче. После размещения в куче значение принадлежит объекту `Box`. И когда значение выходит за пределы области видимости, Box автоматически освобождает память.

```rs
fn main() {
    let b = Box::new(5);
    println!("b = {b}");
}
```

[Запуск кода в песочнице](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=ef92bdc67410c0f16fd28d7d9baa6f67)


Box удобно применять в следующих случаях:

- Когда данные некоторого типа, размер которого не может быть известен во время компиляции, необходимо использовать в контексте, где компилятору требуется точный размера данных

- Когда имеется большой объем данных, и необходимо передать право собственности и при этом гарантировать, что данные не будут скопированы.

Передача права собственности на большой объем данных может занять много времени, поскольку данные копируются в стек. Чтобы повысить производительность в этой ситуации, можно хранить большой объем данных в куче в `Box`. Затем в стеке копируется лишь небольшой объем данных указателя, а данные, на которые он ссылается, остаются в одном месте в куче.

- Когда надо владеть некоторым значением, о типе которого известно только то, что он реализует определенный трейт.

## Rc

`Rc` (Reference Counter или счетчик ссылок) добавляет в язык **Rust** концепцию разделяемого (общего) владения. В то время как стандартная модель владения **Rust** обычно предполагает наличие одного владельца для некоторого значения, `Rc` позволяет нескольким владельцам совместно использовать одни и те же данные. `Rc` отслеживает количество ссылок на данные и автоматически освобождает память при удалении последней ссылки.

`Rc` предоставляет возможность иметь несколько читателей одних и тех же данных, что делает его полезным для сценариев, когда необходимо совместно использовать одни и те же данные в разных частях программы. Однако стоит отметить, что `Rc` не гарантирует потокобезопасность. Наглядный пример расположения в памяти вектора, для которого с помощью `Rc` установлен ряд владельцев:

![](https://metanit.com/rust/tutorial/pics/9.8.png)

```rs
use std::rc::Rc;

fn main() {
    let data = Rc::new(vec![1, 2, 3, 4, 5]);
    let clone1 = Rc::clone(&data);
    let clone2 = Rc::clone(&data);

    let sum: i32 = data.iter().sum();
    let len: usize = data.len();
    println!("Sum: {}   Len: {}", sum, len);

    println!("Data: {:?}", data);
    println!("Clone1: {:?}", clone1);
    println!("Clone2: {:?}", clone2);
}
```

[Запуск кода в песочнице](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=753b12da0b28da2d16163711558420b5)

::: warning Копирование Rc
Стоит отметить, что функция `Rc::clone()` в реальности не копирует данные, а лишь увеличивает счетчик ссылок. Поскольку глубое копирование данных особенно больших наборов данных может вызвать просадку по производительности. Для подчета ссылок на какой-то объект мы можем использовать функцию `Rc::strong_count()`:
:::

## RefCell

Указатель типа `RefCell` позволяет изменять данные, на которые он ссылается. Причем `RefCell` предоставляет возможность динамически изменять данные, сохраняя неизменность самой переменной. Это достигается благодаря тому, что в отличие от Box правила владения-заимствования проверяются во время выполнения программы, а не во время компиляции. Хотя также `RefCell` позволяет работать с данными и как с неизменяемыми значениями.

Получение неизменяемой ссылки:
```rs
use std::cell::RefCell;

fn main() {
    let data = RefCell::new(vec![1, 2, 3]);
    let data_ref = data.borrow();

    println!("Data: {:?}", data_ref);
    // data_ref.push(4); // Ошибка
}
```

[Запуск кода в песочнице](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=84d14dc9f27d1a6a0402ea42b55c1557)

Получение изменяемой ссылки:
```rs
use std::cell::RefCell;

fn main() {
    let data = RefCell::new(vec![1, 2, 3]);
    let mut data_ref_mut = data.borrow_mut();

    println!("Original Data: {:?}", data_ref_mut);
    data_ref_mut.push(4);
    println!("Modified Data: {:?}", data_ref_mut);
}
```

[Запуск кода в песочнице](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=0d3a7bc9f1ff40f81d7ae624633fa7ab)


## Задание для выполнения

Необходимо реализовать структуру `TreeNode<T>`. Структура является рекурсивной и хранит значения своего узла и дочернии узлы.

Для данной структуры необходимо реализовать следующие признаки:

- `From<&Rc<RefCell<T>>>`
- `From<T>`
- `IntoIterator`

а также методы:
- `fn add_child(&mut self, node: Node<T>)`
- `fn is_leaf(&self) -> bool`

Код для проверки работы структуры
```rs
fn main() {
    let n1_value = Rc::new(RefCell::new(1));

    let mut n1: Node<i32> = Node::from(&n1_value);
    n1.add_child(Node::from(5));

    let n2: Node<i32> = Node::from(&n1_value);

    *n1_value.borrow_mut() += 100;

    let mut n3 = Node::from(3);
    n3.add_child(n1.clone());
    n3.add_child(n2.clone());

    println!("{:?}", n3);

    for n in n3 {
        println!("{:?}", n.is_leaf());
    }
}
```

::: warning Значение узла
Значение, хранящееся в структуре может быть общим между разными узлами.
:::

[Более подробная информация о деревьях](https://en.wikipedia.org/wiki/Tree_(abstract_data_type))
