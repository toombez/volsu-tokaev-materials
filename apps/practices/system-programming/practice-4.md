# Владение, заимствование, перемещение и структуры

## Владение

Собственность - это набор правил, которые определяют, как программа **Rust** управляет памятью. Все программы должны управлять тем, как они используют память компьютера во время работы. В некоторых языках есть сборка мусора, которая регулярно ищет неиспользуемую память по мере выполнения программы; в других языках программист должен явно выделять и освобождать память. В **Rust** используется третий подход: память управляется через систему владения с набором правил, которые проверяет компилятор. Если какое-либо из правил нарушено, программа не будет скомпилирована. Ни одна из особенностей владения не замедлит работу вашей программы во время ее выполнения.

### Правила владения

Владение характеризуется следующими правилами:

- Каждое значение в **Rust** имеет владельца.
- Одновременно может быть только один владелец.
- Когда владелец выходит за пределы области действия, значение будет выгружено из памяти.

### Область видимости

```rs
let s = "hello";
```

Переменная ```s``` ссылается на строковый литерал, где значение строки жестко закодировано в тексте нашей программы. Переменная действительна с момента ее объявления и до конца текущей области видимости. Ниже показана программа с комментариями, в которых указано, где будет действовать переменная s.

```rs
{                      // s не ещё не инициализированна
        let s = "hello";   // s доступна, начиная с этой строки

        // операции с s
}    // Область видимости закончилась и переменная s больше не существует
```

Другими словами, здесь есть два важных момента времени:

- Когда ```s``` входит в область действия, она становится действительным.
- Она остается действительным до тех пор, пока не выйдет из области действия.

### Перемещение

В **Rust** несколько переменных могут по-разному взаимодействовать с одними и теми же данными:

```rs
let x = 5;
let y = x;
```

[Запуск в песочнице](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=7f7bd4f22e6f3fe898ea9dedaae19054)

Мы, вероятно, можем догадаться, что это делает: «привязать значение ```5``` к ```x```; затем сделать копию значения в ```x``` и привязать ее к ```y```». Теперь у нас есть две переменные, ```x``` и ```y```, и обе они равны ```5```. Это действительно то, что происходит, потому что целые числа - это простые значения с известным, фиксированным размером, и эти два значения ```5``` добавляются в стек.

Версия со строками

```rs
let s1 = String::from("hello");
let s2 = s1;
```

[Запуск в песочнице](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=93605a259416cf79f5ed9f33a3350cc7)

Это выглядит очень похоже, поэтому можно предположить, что принцип работы будет таким же: то есть вторая строка создаст копию значения в ```s1``` и свяжет его с ```s2```. Однако все происходит не совсем так.

Чтобы обеспечить безопасность памяти, после строки ```let s2 = s1```; **Rust** считает ```s1``` больше недействительным. Поэтому **Rust** не нужно ничего освобождать, когда ```s1``` выходит из области видимости. Проверьте, что произойдет, если вы попытаетесь использовать s1 после создания s2; это не сработает:

```rs{4}
let s1 = String::from("hello");
let s2 = s1;

println!("{s1}, world!"); // Ошибка
```

### Copy и Clone

Чтобы переменные не теряли право владельца над данными мы можем копировать их значения в другие переменные:

::: code-group
```rs{2} [Копирование примитивов]
let x = 5;
let y = x; // Здесь неявно вызывается метод copy

println!("x = {x}, y = {y}");
```

```rs{2} [Копирование сложных данных]
let s1 = String::from("hello");
let s2 = s1.clone(); // Необходимо явно копировать данные с помощью метода clone

println!("s1 = {s1}, s2 = {s2}");
```
:::

[Запуск в песочнице](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=8a85ecc40052369c28fbb080753df0b4)

Неявно копируются данные с помощью ```copy```:
- целочисленные типы, такие как ```u32```.
- Булевский тип, ```bool```, со значениями ```true``` и ```false```.
- Все типы с плавающей точкой, например ```f64```.
- Символьный тип, ```char```.
- Кортежи, если они содержат только типы, которые также реализуют ```Copy```. Например, ```(i32, i32)``` реализует ```Copy```, а ```(i32, String)``` - нет.

### Владение и функции

Механика передачи значения в функцию похожа на ту, что используется при присвоении значения переменной. Передача переменной в функцию перемещает или копирует ее, как и присваивание. Ниже приведен пример с некоторыми аннотациями, показывающими, где переменные входят и выходят из области видимости.

```rs
fn main() {
  let s = String::from("hello");  // s появляется в области видимости main

  takes_ownership(s);             // s перемещается в область видимости
                                  // функции takes_ownership и пропадает из
                                  // области видимости main

  let x = 5;                      // x появляется в области видимости main

  makes_copy(x);                  // x перемещается в область, но i32
                                  // реализует Copy, что позволяет
                                  // использовать x в области видимости main

} // x выходит из области видимости, затем s. S была перемещена - ничего
  // особенного не происходит

fn takes_ownership(some_string: String) { // Строка появляется в области
                                          // видимости
    println!("{some_string}");
} // Здесь строка some_string выходит из области видимости и память очищается

fn makes_copy(some_integer: i32) { // целое число входит в область видимости
    println!("{some_integer}");
}
```

[Запуск в песочнице](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=d5c466226d45dbadcbe2c7de1cc702b7)

### Возврат значений из функции и область видимости

Возвращение значений также может передавать право собственности. Ниже показан пример функции, возвращающей некоторое значение.

```rs
fn main() {
    let s1 = gives_ownership();         // gives_ownership перемещает
                                        // результат в переменную s1

    let s2 = String::from("hello");     // s2 появляется в области видимости

    let s3 = takes_and_gives_back(s2);  // s2 перемещается в
                                        // takes_and_gives_back, которая
                                        // возращает значение в s3
} // Здесь s3 выходит из области и пропадает. s2 была перемещена, поэтому
  // ничего особенного не происходит. s1 выходит из области и пропадает.

fn gives_ownership() -> String {             // gives_ownership перемещает
                                             // возврат в область той функции,
                                             // в которой была вызвана

    let some_string = String::from("yours"); // some_string появляется
                                             // в области

    some_string                              // some_string возвращается и
                                             // перемещает значение в область
                                             // той функции, в которой была
                                             // вызвана
}

// Функция принимает и возращает строку
fn takes_and_gives_back(a_string: String) -> String { // a_string появляется
                                                      // в области

    a_string  // a_string возвращается и перемещается в область той функции,
              // в которой была вызвана
}
```

[Запуск в песочнице](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=170750757b60b5260b1c9ff48aae6d1f)

## Ссылки и заимствование

Основная проблема с функциями, которые принимают значение в качестве параметра и возвращают это же значение заключается с том, что для возврата другого знаечния нам необходимо использовать кортежи. Для решения этой проблемы используется механизм заимствования.

Вот как можно определить и использовать функцию ```calculate_length```, которая имеет в качестве параметра ссылку на объект, а не принимает на себя право собственности на значение:

```rs
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{s1}' is {len}.");
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

[Запуск в песочнице](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=d022a5a0bac16fd0cad26cecdbf89bbe)

Синтаксис ```&s1``` позволяет нам создать ссылку, которая ссылается на значение ```s1```, но не владеет им. Поскольку она не владеет им, значение, на которое она указывает, не будет уничтожено, когда ссылка перестанет использоваться.

Аналогично, в сигнатуре функции используется ```&```, чтобы указать, что тип параметра ```s``` - ссылка.

Область видимости переменной ```s``` такая же, как и у любого параметра функции, но значение, на которое указывает ссылка, не исчезает, когда ```s``` перестает использоваться, потому что у ```s``` нет права собственности. Когда функции имеют ссылки в качестве параметров вместо фактических значений, нам не нужно возвращать значения, чтобы вернуть право собственности, потому что у нас никогда не было права собственности.

Действие по созданию ссылки мы называем заимствованием. Как и в реальной жизни, если человек владеет чем-то, вы можете одолжить это у него. Когда вы закончите, вам придется вернуть его. Вы им не владеете.

### Мутабельные ссылки

Мы можем хранить ссылки на мутабельные данные в нашем коде.

```rs
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

[Запуск в песочнице](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=de584bc1756596d151a4ac80c70a51e7)

У мутабельных ссылок есть одно большое ограничение: если у вас есть мутабельная ссылка на значение, у вас не может быть других ссылок на это значение. Код, который попытается создать две мутабельные ссылки на ```s```.

```rs{4}
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s; // Ошибка из-за нескольких мутабельных ссылок

println!("{}, {}", r1, r2);
```

[Запуск в песочнице](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=ba19d5ce630040b0f97d48e7ca2482dd)

### Висячие ссылки (указатели)

В языках с указателями легко ошибочно создать висячий указатель - указатель, ссылающийся на место в памяти, которое могло быть передано кому-то другому, - освободив некоторую память и сохранив указатель на эту память. В **Rust**, напротив, компилятор гарантирует, что ссылки никогда не будут висячими: если у вас есть ссылка на некоторые данные, компилятор гарантирует, что данные не выйдут из области видимости до того, как это сделает ссылка на них.

Давайте попробуем создать висячую ссылку, чтобы посмотреть, как **Rust** предотвращает их появление с помощью ошибки времени компиляции:

```rs{8}
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s // Ошибка из-за висячей ссылки
}
```

Решение состоит в том, чтобы вернуть строку напрямую:

```rs
fn no_dangle() -> String {
    let s = String::from("hello");

    s
}
```

## Определение структур

**Структура** - это пользовательский тип данных, позволяющий объединять и называть несколько связанных значений, которые образуют значимую группу.

Структуры похожи на кортежи тем, что оба хранят несколько связанных значений. Как и кортежи, части структуры могут быть разных типов. В отличие от кортежей, в структуре вы даете имя каждой части данных, чтобы было понятно, что означают те или иные значения. Добавление таких имен означает, что структуры более гибкие, чем кортежи: вам не нужно полагаться на порядок данных, чтобы указать или получить доступ к значениям экземпляра.

::: details Кортеж, хранящий разные типы данных
```rs
let tuple: (i32, bool, String) = (5, true, String::from("Hello world"));
```
:::

Чтобы определить структуру, мы вводим ключевое слово struct и называем всю структуру. Имя структуры должно описывать значение частей данных, которые будут сгруппированы вместе. Затем, внутри фигурных скобок, мы определяем имена и типы фрагментов данных, которые называем полями. Например, ниже показана структура, хранящая информацию об учетной записи пользователя.

```rs
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```

### Использование структур

Чтобы использовать структуру после ее определения, мы создаем экземпляр этой структуры, указывая конкретные значения для каждого из полей. Мы создаем экземпляр, указывая имя структуры, а затем добавляем фигурные скобки, содержащие пары ключ: значение, где ключи - это имена полей, а значения - это данные, которые мы хотим хранить в этих полях. Нам не обязательно указывать поля в том же порядке, в котором мы объявили их в структуре. Другими словами, определение ```struct``` - это как общий шаблон для типа, а экземпляры заполняют этот шаблон конкретными данными для создания значений типа. Например, мы можем объявить конкретного пользователя:

```rs
// --snip--

fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}
```

Чтобы получить конкретное значение из структуры, мы используем точечную нотацию. Например, чтобы получить адрес электронной почты этого пользователя, мы используем ```user1.email```. Если экземпляр является изменяемым, мы можем изменить значение, используя точечную нотацию и присваивая его определенному полю. Ниже показано, как изменить значение в поле ```email``` изменяемого экземпляра ```User```.

```rs
fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };

    user1.email = String::from("anotheremail@example.com");
}
```

Обратите внимание, что весь экземпляр должен быть изменяемым; Rust не позволяет нам помечать как изменяемые только определенные поля. Как и в любом выражении, мы можем построить новый экземпляр ```struct``` в качестве последнего выражения в теле функции, чтобы неявно вернуть этот новый экземпляр.

Ниже приведена функция ```build_user```, которая возвращает экземпляр ```User``` с заданными ```email``` и именем пользователя. Поле ```active``` получает значение ```true```, а ```sign_in_count``` - значение ```1```.

```rs
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
```

Имеет смысл называть параметры функции теми же именами, что и поля структуры, но повторять имена полей ```email``` и ```username``` и переменных немного утомительно. Если бы в ```struct``` было больше полей, повторение каждого имени стало бы еще более утомительным. Ниже показано, как можно сократить рутинную передачу значений:

```rs
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username,
        email,
        sign_in_count: 1,
    }
}
```

### Использование экземпляра структуры для создания нового экземпляра

Часто бывает полезно создать новый экземпляр структуры, включающий большинство значений из другого экземпляра, но изменяющий некоторые. Это можно сделать с помощью синтаксиса обновления ```struct``` (**struct update syntax**).

::: code-group
```rs [Не используя struct update syntax]
fn main() {
    // --snip--

    let user2 = User {
        active: user1.active,
        username: user1.username,
        email: String::from("another@example.com"),
        sign_in_count: user1.sign_in_count,
    };
}
```

```rs [Используя struct update syntax]
fn main() {
    // --snip--

    let user2 = User {
        email: String::from("another@example.com"),
        ..user1
    };
}
```
:::

[Запуск в песочнице](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=5c7d5b2bdc3237fdd5a838fd31eccd7d)

### Tuple-структуры

**Rust** также поддерживает структуры, похожие на кортежи, которые называются кортежными структурами (**tuple-struct**). Tuple-структуры позволяют хранить несколько значений, что обеспечивает имя **struct**, но значений не имеют ключей, связанных с их полями; скорее, они просто содержат типы полей. Структуры кортежей полезны, когда вы хотите дать имя всему кортежу и сделать его отличным от других кортежей, и когда именование каждого поля, как в обычной структуре, было бы многословным или избыточным.

```rs
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
```

Обратите внимание, что значения ```black``` и ```origin``` имеют разные типы, потому что они являются экземплярами разных кортежных структур. Каждая определенная вами структура имеет свой собственный тип, даже если поля внутри структуры могут иметь одинаковые типы. Например, функция, принимающая параметр типа ```Color```, не может принять в качестве аргумента ```Point```, даже если оба типа состоят из трех значений ```i32```. В остальном экземпляры tuple-struct похожи на кортежи тем, что их можно деструктурировать на отдельные части, а для доступа к отдельному значению можно использовать символ ```.```, за которым следует индекс.

```rs
fn main() {
    let origin = Point(0, 0, 0);

    let x = origin.0;
    let y = origin.1;
    let z = origin.2;
}
```

[Запуск в песочнице](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=2b0bbd8b1f17c0cc96cf8b86d4e8ec8c)

### Unit-like-структуры

Вы также можете определять структуры, у которых нет полей. Такие структуры называются unit-like, потому что они ведут себя аналогично единичному типу (```()```). Unit-like-структуры могут быть полезны, когда вам нужно реализовать признак для некоторого типа, но у вас нет данных, которые вы хотели бы хранить в самом типе. Вот пример объявления и инстанцирования unit-like-структуры с именем ```AlwaysEqual```:

```rs
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
```

Чтобы определить ```AlwaysEqual```, мы используем ключевое слово ```struct```, нужное нам имя, а затем точку с запятой. Никаких фигурных скобок или круглых скобок не нужно! Затем мы можем получить экземпляр ```AlwaysEqual``` в переменной ```subject``` аналогичным образом: используя имя, которое мы определили, без фигурных скобок и круглых скобок. Представьте, что позже мы реализуем поведение для этого типа таким образом, чтобы каждый экземпляр ```AlwaysEqual``` всегда был равен любому экземпляру любого другого типа, возможно, чтобы иметь известный результат для целей тестирования. Для реализации такого поведения нам не понадобятся никакие данные!

### Методы структур

Методы похожи на функции: мы объявляем их с помощью ключевого слова ```fn``` и имени, у них могут быть параметры и возвращаемое значение, и они содержат некоторый код, который запускается, когда метод вызывается из другого места. В отличие от функций, методы определяются в контексте структуры, и их первым параметром всегда является ```self```, который представляет собой экземпляр структуры, на которой вызывается метод.

```rs Определение метода структуры Rectangle
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```

Чтобы определить функцию в контексте ```Rectangle```, мы создаем блок ```impl``` (реализации) для ```Rectangle```. Все внутри этого ```impl```-блока будет связано с типом ```Rectangle```.

В сигнатуре для ```area``` используется ```&self``` вместо ```rectangle: &Rectangle```. На самом деле ```&self``` - это сокращение от ```self: &Self```. Внутри блока реализации тип ```Self``` является псевдонимом для типа, для которого предназначен блок реализации. Методы должны иметь параметр с именем ```self``` типа ```Self``` в качестве первого параметра, поэтому **Rust** позволяет вам сократить это, используя только имя ```self``` в месте первого параметра. Обратите внимание, что нам все еще нужно использовать символ ```&``` перед сокращением ```self```, чтобы указать, что этот метод заимствует экземпляр ```Self```. Методы могут принимать право собственности на ```self```, заимствовать неизменяемый ```self```, или заимствовать мутабельный ```self```.

#### Методы с названиями полей

Обратите внимание, что мы можем дать методу то же имя, что и одному из полей ```struct```. Например, мы можем определить метод для ```Rectangle```, который также будет называться ```width```:

```rs
impl Rectangle {
    fn width(&self) -> bool {
        self.width > 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    if rect1.width() {
        println!("The rectangle has a nonzero width; it is {}", rect1.width);
    }
}
```

В данном случае мы хотим, чтобы метод ```width``` возвращал ```true```, если значение в поле ```width``` экземпляра больше ```0```, и ```false```, если значение равно ```0```: мы можем использовать поле внутри одноименного метода для любых целей. В ```main```, когда мы заключаем ```rect1.width``` в круглые скобки, **Rust** знает, что мы имеем в виду метод ```width```. Если мы не используем круглые скобки, **Rust** знает, что мы имеем в виду поле ```width```.

#### Множество параметров метода

Методы могут иметь больше одного параметра. Например, реализуем метод ```can_hold```, который будет проверять, можно ли поместить один экземпляр ```Rectangle``` в другой экземпляр. Если это возможно, то возращаем ```true```, иначе - ```false```.

::: code-group
```rs [Реализация]
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```

```rs [Программа]
fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}
```

```sh [Вывод]
Can rect1 hold rect2? true
Can rect1 hold rect3? false
```
:::

#### Ассоциативные функции

Все функции, определенные в блоке ```impl```, называются ассоциированными функциями, потому что они связаны с типом, названным в блоке ```impl```. Мы можем определить ассоциированные функции, которые не имеют ```self``` в качестве первого параметра (и, следовательно, не являются методами), потому что им не нужен экземпляр типа для работы. Мы уже использовали одну такую функцию: функцию ```String::from```, которая определена для типа ```String```.

```rs
impl Rectangle {
    fn square(size: u32) -> Self {
        Self {
            width: size,
            height: size,
        }
    }
}
```

Ключевое слово ```Self``` в возвращаемом типе и в теле функции являются псевдонимами для типа, стоящего после ключевого слова ```impl```, которым в данном случае является ```Rectangle```.

Чтобы вызвать эту связанную функцию, мы используем синтаксис ```::``` с именем ```struct```; пример:

```rs
let sq = Rectangle::square(3);
```

Эта функция имеет пространство имен структуры.

Синтаксис ```::``` используется как для ассоциированных функций, так и для пространств имен, создаваемых модулями.

#### Несколько impl блоков

Каждая структура может иметь несколько ```impl```-блоков. Например:

```rs
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```

[Запуск в песочнице](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=4343d823c9da0f5a1fd29f9718c9a380)

## Задания для выполнения

### Задание 1

Необходимо создать структуру ```Person``` и функции для неё:

- функция ```print_person_info(person: &Person)```, которая принимает неизменяемую ссылку на экземпляр ```Person``` и печатает его информацию. Исходный ```Person``` не должен быть изменен.

- функция ```increase_age(person: &mut Person)```, которая принимает мутабельную ссылку на экземпляр ```Person``` и увеличивает его возраст на ```1```.

- Создайте функцию ```consume_person(person: Person)```, которая принимает право собственности над экземпляром ```Person``` и печатает прощальное сообщение, забирая право владения, чтобы его нельзя было использовать повторно.

#### Пример

Пример работы с структурой

```rs
fn main() {
    let mut person = Person {
        name: String::from("ФИО"),
        age: 25,
        ordinal_number: 25,
    };

    // 1. Неизменяемое заимствование: Передайте человека как ссылку, чтобы прочитать его данные.
    print_person_info(&person);  // `person` заимствуется неизменно, поэтому его можно использовать позже

    // 2. Мутабельное заимствование: Передайте `person` в виде изменяемой ссылки, чтобы изменить ее данные.
    increase_age(&mut person);  // `person` заимствуется мутативно для изменения возраста

    // 3. Владение: Передать право собственности на `человека` другой функции
    consume_person(person);  // `person` перемещается сюда, поэтому не может быть использован после этого

    // После `consume_person`, `person` больше не может быть использован, так как право собственности было передано.
}
```

### Задание 2

Необходимо создать структуру ```BankAccount```, в которой процентная ставка будет определена по следующему правилу:

- Если номер по списку группы делится на ```3```, то процентная ставка равна ```3%```
- Если номер по списку группы делится на ```7```, то процентная ставка равна ```7%```
- В остальных случаях - ```1.5%```

::: info Пояснение структуры
Определите структуру ```BankAccount``` с полями: ```account_holder``` (Имя владельца/студента), ```balance``` (Баланс владельца) и ```ordinal_number``` (Номер по списку группы).

Реализуйте метод ```apply_interest()```, который начисляет проценты на основе порядкового номера:
Баланс должен быть обновлен на основе этих процентов.
:::

#### Пример

Для студента, который идет $25$ по списку группы программа будет выводить следующее:

```rs
fn main() {
    let mut account = BankAccount {
        account_holder: "ФИО"
        balance: 1000
        ordinal_number: 25
    };

    account.apply_interest();

    println!("{:?}", account.balance) // 1015
}
```

### Задание 3

Необходимо создать структуру ```Employee``` с полями ```name```, ```position```, ```years_of_service```

Для этой структуры необходимо реализовать следующие методы:

- ```new(name: String, position: String)``` для создания нового экземпляра сотрудника и его возврата;
- ```get_default_employee()```, для создания экземпляра Employee со значениями по умолчанию;
- ```update_position(&mut self, new_position: String)```, для мутабельного заимствования и обновления должности сотрудника.
- ```promote_employee(employee: Employee)```, для принятия методом права собственности над экземпляром ```Employee```, повышая его в должности, печатая сообщение об повышении и удалении сотрудника из программы.

#### Пример

```rs
fn main() {
    // Использование статического метода для создания нового сотрудника
    let mut employee = Employee::new(String::from("Bob"), String::from("Software Developer"));

    // Обновление позиции с использованием мутабельных заимствований
    employee.update_position(String::from("Senior Developer"));

    // Использование статического метода для получения сотрудника по умолчанию
    let default_employee = Employee::get_default_employee();
    println!("Default employee: {}, {}", default_employee.name, default_employee.position);

    // Продвижение сотрудника (потребляет структуру)
    Employee::promote_employee(employee);

    // После этого `employee` больше не используется
}
```

### Задание 4

Необходимо создать систему управления предметами, использующую право собственности и заимствования.

- Определите структуру ```Item``` с полями: ```name```, ```quantity``` и ```price```.
- Реализуйте **метод** ```check_availability(&self)```, который принимает неизменяемую ссылку и выводит, есть ли товар в наличии (количество > 0).
- Реализуйте **метод** ```sell_item(&mut self, amount: u32)```, который принимает мутабельную ссылку и уменьшает количество товара на указанную сумму.
- Реализуйте **функцию** ```process_sale(item: Item, amount: u32)```, которая принимает право собственности на предмет, печатает итоговую стоимость продажи и удаляет предмет из программы.

#### Пример

```rs
fn main() {
    let mut item = Item {
        name: String::from("Laptop"),
        quantity: 10,
        price: 999.99,
    };

    item.check_availability();        // Неизменяемое заимствование
    item.sell_item(3);                // Изменяемое заимствование
    process_sale(item, 3);            // Владение перешло в функцию
}
```

### Задание 5

Необходимо создать структуру ```Matrix```, которая хранит в себе двумерный вектор. Для структуры реализуйте метод генерации данных ```generate(&self)```, который заполняет двумерный вектор, метод ```print_matrix(&self)```, метод ```calculate(&mut self)```, который преобразует значения внутри структуры по следующей формуле:

$$(x_{i,j} \bmod 20) * N,$$

где $N$ - номер по списку группы, $x_{i,j}$ - число из двумерного вектора под строкой $i$ и столбцом $j$. $\bmod$ - операция нахождения остатка от деления.

::: info Модуль ```rand```
Для генерации значений можно использовать крейт **rand**, который можно подключить следующим образом:

::: code-group
```rs [Подключение]
// В playground будет работать так. Для локальной разработки необходимо править cargo.toml
use rand::Rng;

fn main() {
    let mut rng = rand::thread_rng();

    println!("{}", rng.gen::<u8>());
}
```

```toml{7} [Подключение в cargo.toml]
[package]
name = "rust_intro_bin"
version = "0.1.0"
edition = "2021"

[dependencies]
rand = "0.8.5"
```
:::
