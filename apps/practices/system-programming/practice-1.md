# Знакомство с языком программирования Rust

## Установка Rust

Для работы с **Rust** можно воспользоваться 2 методами:

1. [Установка на локальную машину](https://doc.rust-lang.org/book/ch01-01-installation.html).
2. [Работа в песочнице](https://play.rust-lang.org/).

Каждый из вариантов работы с **Rust** имеет свои недостатки и преимущества.

::: info Метод работы с **Rust** на практиках
Во время выполнения практик предполагается, что экосистема **Rust** установлена локально на рабочую машину.
:::

## Создание и запуск проекта

Для того, чтобы создать проект **Rust**, необходимо выполнить следующее:

1. Перейти в директорию, в которой будет находиться проект:

```sh
cd <Путь до директории>
```

2. Создать проект:

::: code-group

```sh [Создание библиотеки]
cargo new --lib <Название библиотеки>
```

```sh [Создание исполняемого модуля]
# Без явного указания, что модуль исполняемый
cargo new <Название модуля>

# С явным указанием, что модуль исполняемый
cargo new --bin <Название модуля>
```

:::

:::info Выбор проекта для практических работ
Для выполнения практических работ будут использоваться исполняемые модули.
:::

После создания проекта, получаем следующую структуру:

```sh
project
├── cargo.toml # Метаданные для проекта
└── src # директория с исходым кодом модуля
   ├── main.rs # Если выбран параметр `--bin` | точка входа в программу
   └── lib.rs # Если выбран параметр `--lib` | публичный модуль библиотеки
```

Для запуска проекта, необходимо перейти в директорию проекта и выполнить команду запуска:

::: code-group

```sh [Используя cargo]
cd project
cargo run
```

```sh [Используя rustc]
# Компиляция исходных файлов
rustc ./src/main.rs

# Запуск модуля
./main.exe
```

:::

::: info Детали работы ```cargo run```
1. Для успешного запуска проекта, в нем обязательно должен находиться файл ```main.rs```, который является точкой входя для приложений, написанных на **Rust**.

2. Во время выполнения ```cargo run``` сначала запускает команду ```rustc <модуль для компиляции>``` и запуск скомпилированного модуля.
:::

## Анатомия программы **Rust**

```rs
fn main() {
    println!("Hello, world!");
}
```

[Запуск в песочнице](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=0b455eb97d9cb6f3ec6c4ed6a54f5c56)

В данном блоке кода определяется функция ```main```, которая будет точкой входа в программу. В теле функции находится макрос ```println!```, который выводит в поток вывода информацию, которая передается в качестве параметра. В нашем случае строка **"Hello, world!"**.

## Вывод в терминал

Для вывода информации в терминал в **Rust** существует несколько методов. Основным для нас сейчас является макросы ```println!()``` и ```print!()```. ```println!()``` позволяет отобразить информацию в форматированном виде:

```rs
println!("Hello, {}!", "world"); // Отобразит "Hello, world!"
```

```rs
print!("{}", "Hello"); // Отобразит "Hello"
print!(" {}", "world!"); // Добавит к предыдущему выводу " world!".
// Отобразит "Hello world!"
```

Вместо ```{}``` подставится параметр, который мы передаем после форматированной строки.

::: info Индекс параметра, передаваемого в форматированную строку
```{}``` шаблон может принимать целое число, чтобы определить индекс параметра, который необходимо отобразить:

```rs
println!("{0}: {1} - {0}", "A", "B"); // Отобразит "A: B - A"
```
:::

::: warning Отображение данных, не реализуюзих ```fmt::Display```
В **Rust** существует ```trait``` ```fmt::Display```, который позволяет отображать данные в удобном для человека формате. Данные, которые реализуют данный ```trait``` позволяют подставлять свои значения в ```{}``` или ```{variable_name}``` при форматированном выводе в консоль. Для данных которые не реализуют данный ```trait```, необходимо использовать ```{:?}``` или ```{variable_name:?}```. Данная запись будет использовать ```trait``` ```Debug```, который реализован во всех данных **Rust**.

```rs
let array = [2, 3];

println!("{:?}", array); // Вывод работает
println!("{}", array); // Ошибка
```
[Запуск в песочнице](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=5719548d1331391cdda745f5c35b842e)
:::

## Типы данных **Rust**

**Rust** предоставляет доступ к большому количеству примитивных типов данных:

### Скалярные типы

- знаковые целочисленные: ```i8```, ```i16```, ```i32```, ```i64``` и ```isize``` (размер указателя);
- беззнаковые целочисленные: ```u8```, ```u16```, ```u32```, ```u64``` и ```usize``` (размер указателя);
- вещественные: ```f32```, ```f64```;
- ```char``` скалярное значение [**Unicode**](https://en.wikipedia.org/wiki/Unicode), например: ```'a'```, ```'α'``` и ```'∞'``` (4 байта каждый);
- ```bool```: ```true``` или ```false```;
- единичный тип ```()```, значение которого так же ```()```.

::: info Единичный тип
Несмотря на то, что значение единичного типа является кортежем, оно не считается составным типом, потому что не содержит нескольких значений.
:::

### Составные типы

- массивы, например ```[1, 2, 3]```;
- кортежи, например ```(1, true)```.

::: info Аннотация типов
Переменные всегда должны быть аннотированы. Числам можно указать определённый тип с помощью суффикса, иначе будет присвоен тип по умолчанию. Целочисленные значения по умолчанию ```i32```, а вещественные ```f64```. Стоит заметить, что **Rust** также умеет выводить типы из контекста.
:::

## Операции над числовыми типами данных

Для числовых операций определены базовые математические операции:

- ```+``` для операций сложения;
- ```-``` для операций вычитания;
- ```*``` для операций умножения;
- ```/``` для операций деления;
- ```%``` для операций нахождения остатка от деления;
- метод ```.pow``` и ```.powf``` для операций возведения в степень для целых и чисел с плавающей запятой соответственно.

```rs
println!("{}", 1 + 2); // 3
println!("{}", 7 - 9); // -2
println!("{}", 4 * 2); // 8
println!("{}", 9 / 3); // 3
println!("{}", 5 % 2); // 1
println!("{}", 5_i32.pow(2)); // 25
println!("{}", 5.0_f64.powf(2.0)); // 25
```

[Запуск в песочнице](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=dc09e3a6b0f2bd348e25bef20254598f)

::: info Методы ```pow``` и ```powf```
Требуют от пользователя указывать тип данных, с которыми производится операция:

```rs
let integer_number: i32 = 4;
let float_number: f64 = 4.0;

println!("{}", integer_number.pow(2)); // 16 - i32 тип данных
println!("{}", float_number.powf(2.0)); // 16.0 - f64 тип данных
println!("{}", 4_i32.pow(2)); // 16 - i32 тип данных
println!("{}", 4.0_f64.powf(2.0)); // 16.0 - f64 тип данных
```
[Запуск в песочнице](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=fb64145363e1e32dd1d82da6658024dd)
:::

::: info Ограничения при работе с разными типами
**Rust** не умеет автоматически преобразовывать данные одного типа в другой, что заставляет программиста явно указывать преобразование типов:

```rs
println!("{}", (2.0 as i32) * 2); // Выполнит вычисление
println!("{}", 2.0 * 2); // Выдаст ошибку
```
[Запуск в песочнице](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a5174d0cc48e07593c9da5105027bee5)
:::

## Объявление переменных

Для создания переменных в **Rust** используется ключевое слово ```let``` и ```const```, разница между которыми заключается в том, как значения создаются на моменте компиляции.

Тип данных для переменной **Rust** может определить сам, на основании значения:

```rs
let a = 5; // Создаст целочисленную переменную с типом i32.
let b = 5.5; // Создаст числовую переменную с плавующим знаком. По-умолчанию, f64.
let c: i8 = 2; // Создает перенную с типом данных i8.
const d: i32 = 128; // Создать константу с типом i32.
```

::: info Ключевое слово ```const```
Ключевое слово ```const``` требует указания типа данных для константного значения.
:::

::: info Изменяемость переменных
Ключевое слово ```let``` создает иммутабельную переменную, значение которой изменить нельзя. Для того, чтобы сделать мутабельную переменную, необходимо использовать ключевое слово ```mut```:

```rs
let mut a: i32 = 5; // Мутабельная переменная a с типом данных i32.
```
:::

## Написание функций

Функции объявляются с помощью ключевого слова ```fn```. Их аргументы имеют явно заданный тип, как у переменных, и, если функция возвращает значение, возвращаемый тип должен быть указан после стрелки ```->```.

Последнее выражение в функции будет использовано как возвращаемое значение. Так же можно использовать оператор ```return```, чтобы вернуть значение из функции раньше, даже из цикла или оператора ```if``` (о нем позже).

```rs
fn print_hello_world() { // Процедура, которая выводит "Hello, world!" в консоль
    println!("Hello, world!");
}

fn calc_a_plus_b(a: i32, b: i32) -> i32 { // Функция, которая считает сумму параметров `a` и `b`
    a + b
}
```

[Запуск в песочнице](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=f7c49603b958aa8aeade1daa5c3de600)

## Задания для выполнения

### Задание 1

Необходимо написать программу, которая будет выводить номер по списку группы и ФИО в следующем формате: ```№<Номер>: <Фамилия> <Имя> <Отчество>```.

::: warning Примечание
Для значений, выводимых в консоль, необходимо использовать ваши данные.
:::

#### Пример:

```sh
"№1: Иванов Иван Иванович"
```

### Задание 2

Необходимо написать программу, которая выводит в консоль с помощью символов "#" первую букву вашей фамилии размером 6 строчек и 6 столбцов

#### Пример

Для студента, фамилия которого начинается на "И", будет выведено следующее:

```sh
#    #
#   ##
#  # #
# #  #
##   #
#    #
```

### Задание 3

Необходимо написать программу, которая будет вычислять следующее выражение:

$$ N * 15 - \sqrt{(N + 20)},$$

где $N$ - номер по списку группы.

::: warning Примечание
$N$ необходимо создать с помощью ключевого слова ```const```.
:::

#### Пример:

Для студента, который идет 30-м по списку группы, будет выведено следующее:

```sh
Ответ: 442.9289321881345
```

### Задание 4

Наобходимо реализовать функцию с одним параметром - ```R```, которая будет считать площадь круга по формуле:

$$ S = \pi * R^2 , $$

где $R$ - номер по списку группы.

#### Пример

Для студента, который идет 30-м по списку группы, будет выведено следующее:

```sh
Площадь круга с радиусом 30 = 2827.3500000000004
```
